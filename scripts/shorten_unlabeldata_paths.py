#!/usr/bin/env python3
"""Shorten long filenames under src/lib/pesonaldata/unlabeldata."""

from __future__ import annotations

import argparse
import os

from collections import defaultdict
from pathlib import Path
from uuid import uuid4

DEFAULT_RELATIVE_PATH = Path("src/lib/pesonaldata/unlabeldata")
DEFAULT_DIR_TARGET_LENGTH = 200


def _win32_long_path(path: Path) -> str:
    path_str = str(path)
    if os.name != "nt":
        return path_str
    if path_str.startswith("\\\\?\\"):
        return path_str
    if path_str.startswith("\\\\"):
        return "\\\\?\\UNC\\" + path_str.lstrip("\\\\")
    return "\\\\?\\" + path_str


def rename_path(source: Path, target: Path) -> None:
    os.rename(_win32_long_path(source), _win32_long_path(target))


def _strip_long_path_prefix(path_str: str) -> str:
    if path_str.startswith("\\?\\UNC\\"):
        return "\\" + path_str[len("\\?\\UNC\\") :]
    if path_str.startswith("\\?\\"):
        return path_str[len("\\?\\") :]
    return path_str


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--workspace-root",
        type=Path,
        default=Path(__file__).resolve().parents[1],
        help="Workspace root used to resolve relative paths.",
    )
    parser.add_argument(
        "--relative-path",
        type=Path,
        default=DEFAULT_RELATIVE_PATH,
        help="Target directory relative to the workspace root for shortening.",
    )
    parser.add_argument(
        "--max-length",
        type=int,
        default=250,
        help="Only rename files whose current absolute path length exceeds this value.",
    )
    parser.add_argument(
        "--target-length",
        type=int,
        default=240,
        help="Ensure the absolute path length of renamed files is below this value.",
    )
    parser.add_argument(
        "--dir-target-length",
        type=int,
        default=DEFAULT_DIR_TARGET_LENGTH,
        help="Ensure absolute path length of renamed directories is below this value.",
    )
    parser.add_argument(
        "--prefix",
        default="f",
        help="Prefix for autogenerated filenames.",
    )
    parser.add_argument(
        "--dir-prefix",
        default="d",
        help="Prefix for autogenerated directory names.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be renamed without touching files.",
    )
    return parser.parse_args()


def gather_files(root: Path) -> list[Path]:
    root_prefixed = _win32_long_path(root)
    files: list[Path] = []
    for dirpath, _, filenames in os.walk(root_prefixed):
        dir_clean = Path(_strip_long_path_prefix(dirpath))
        for filename in filenames:
            files.append(dir_clean / filename)
    return sorted(files, key=lambda p: str(p))


def gather_dirs(root: Path) -> list[Path]:
    directories: list[Path] = []
    root_prefixed = _win32_long_path(root)
    for dirpath, dirnames, _ in os.walk(root_prefixed):
        dir_clean = Path(_strip_long_path_prefix(dirpath))
        if dir_clean == root:
            continue
        directories.append(dir_clean)
    root_depth = len(root.parts)
    return sorted(
        directories,
        key=lambda p: (
            len(p.parts) - root_depth,
            len(str(p)),
        ),
        reverse=True,
    )



def make_actions(files: list[Path], max_length: int, target_length: int, prefix: str) -> list[tuple[Path, Path]]:
    actions: list[tuple[Path, Path]] = []
    counts = defaultdict(int)
    parents_to_rename = defaultdict(int)

    for file in files:
        parents_to_rename[file.parent] += 1

    counters: dict[Path, int] = defaultdict(int)
    for file in files:
        parent = file.parent
        width = max(4, len(str(parents_to_rename[parent])))
        counter = counters[parent]
        while True:
            candidate = f"{prefix}{counter:0{width}d}{file.suffix}"
            dest = parent / candidate
            if dest.exists():
                counter += 1
                continue
            if len(str(dest)) > target_length:
                raise SystemExit(
                    f"Cannot shorten {file} enough to fit {target_length} characters (candidate {dest})."
                )
            counters[parent] = counter + 1
            actions.append((file, dest))
            break
    return actions


def shorten_actions(actions: list[tuple[Path, Path]], dry_run: bool) -> None:
    if dry_run:
        for source, dest in actions:
            print(f"{source} -> {dest}")
        return

    temp_mapping: list[tuple[Path, Path, str, str]] = []
    for source, dest in actions:
        temp_name = f".tmp_shorten_{uuid4().hex}"
        temp_path = source.parent / temp_name
        rename_path(source, temp_path)
        temp_mapping.append((temp_path, dest, str(source), str(dest)))

    for temp_path, final_path, original, target in temp_mapping:
        rename_path(temp_path, final_path)
        print(f"{original} -> {target}")


def shorten_directories(directories: list[Path], target_length: int, prefix: str, dry_run: bool) -> None:
    if not directories:
        return

    parents_to_rename: dict[Path, int] = defaultdict(int)
    for directory in directories:
        parents_to_rename[directory.parent] += 1

    width_by_parent: dict[Path, int] = {
        parent: max(4, len(str(count)))
        for parent, count in parents_to_rename.items()
    }
    counters: dict[Path, int] = defaultdict(int)

    for directory in directories:
        parent = directory.parent
        width = width_by_parent[parent]
        counter = counters[parent]
        while True:
            candidate = f"{prefix}{counter:0{width}d}"
            dest = parent / candidate
            if dest.exists() and dest != directory:
                counter += 1
                continue
            counters[parent] = counter + 1
            if dry_run:
                print(f"{directory} -> {dest}")
            else:
                temp_name = f".tmp_shorten_dir_{uuid4().hex}"
                temp_path = parent / temp_name
                rename_path(directory, temp_path)
                rename_path(temp_path, dest)
                print(f"{directory} -> {dest}")
            break


def main() -> None:
    args = parse_args()
    workspace_root = Path(args.workspace_root).resolve()
    relative_path = args.relative_path
    if relative_path.is_absolute():
        target_root = relative_path
    else:
        target_root = (workspace_root / relative_path).resolve()

    if not target_root.exists():
        raise SystemExit(f"Target directory {target_root} does not exist.")

    dir_candidates = [d for d in gather_dirs(target_root) if len(str(d)) > args.dir_target_length]
    if dir_candidates:
        print(f"Preparing to rename {len(dir_candidates)} directories under {target_root}.")
        shorten_directories(dir_candidates, args.dir_target_length, args.dir_prefix, args.dry_run)

    all_files = gather_files(target_root)
    candidates = [f for f in all_files if len(str(f)) > args.max_length]
    if not candidates:
        print("No files exceed the configured max length.")
        return

    actions = make_actions(candidates, args.max_length, args.target_length, args.prefix)
    print(f"Preparing to rename {len(actions)} files under {target_root}.")
    shorten_actions(actions, args.dry_run)


if __name__ == "__main__":
    main()
